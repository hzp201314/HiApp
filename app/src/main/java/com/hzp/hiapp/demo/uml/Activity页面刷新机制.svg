<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentScriptType="application/ecmascript" contentStyleType="text/css" height="4582.5px" preserveAspectRatio="none" style="width:971px;height:4582px;" version="1.1" viewBox="0 0 971 4582" width="971.25px" zoomAndPan="magnify"><defs><filter height="300%" id="f1brq1e6xo6s9r" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.5"/><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"/><feOffset dx="5.0" dy="5.0" in="blurOut2" result="blurOut3"/><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"/></filter></defs><g><rect fill="#FFFFFF" filter="url(#f1brq1e6xo6s9r)" height="2212.7313" style="stroke:#A80036;stroke-width:1.25;" width="12.5" x="861.875" y="2301.3245"/><line style="stroke:#A80036;stroke-width:1.25;stroke-dasharray:5.0,5.0;" x1="867.5" x2="867.5" y1="53.9001" y2="4525.3058"/><rect fill="#FEFECE" filter="url(#f1brq1e6xo6s9r)" height="41.4001" style="stroke:#A80036;stroke-width:1.875;" width="176.25" x="777.5" y="6.25"/><text fill="#000000" font-family="sans-serif" font-size="17.5" lengthAdjust="spacing" textLength="158.75" x="786.25" y="35.0549">Choreographer.java</text><rect fill="#FEFECE" filter="url(#f1brq1e6xo6s9r)" height="41.4001" style="stroke:#A80036;stroke-width:1.875;" width="176.25" x="777.5" y="4524.0558"/><text fill="#000000" font-family="sans-serif" font-size="17.5" lengthAdjust="spacing" textLength="158.75" x="786.25" y="4552.8607">Choreographer.java</text><rect fill="#FFFFFF" filter="url(#f1brq1e6xo6s9r)" height="2212.7313" style="stroke:#A80036;stroke-width:1.25;" width="12.5" x="861.875" y="2301.3245"/><line style="stroke:#A80036;stroke-width:1.25;stroke-dasharray:2.0,2.0;" x1="868.125" x2="926.875" y1="2285.0745" y2="2285.0745"/><line style="stroke:#A80036;stroke-width:1.25;stroke-dasharray:2.0,2.0;" x1="926.875" x2="926.875" y1="2285.0745" y2="2301.3245"/><line style="stroke:#A80036;stroke-width:1.25;stroke-dasharray:2.0,2.0;" x1="875.625" x2="926.875" y1="2301.3245" y2="2301.3245"/><polygon fill="#A80036" points="888.125,2296.3245,875.625,2301.3245,888.125,2306.3245,883.125,2301.3245" style="stroke:#A80036;stroke-width:1.25;"/><text fill="#000000" font-family="sans-serif" font-size="16.25" font-weight="bold" lengthAdjust="spacing" textLength="8.75" x="883.125" y="2279.0039">1</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="901.875" y="2279.0039"/><path d="M6.25,72.6501 L6.25,4501.4001 L851.25,4501.4001 L851.25,85.1501 L838.75,72.6501 L6.25,72.6501 " fill="#FBFB77" filter="url(#f1brq1e6xo6s9r)" style="stroke:#A80036;stroke-width:1.25;"/><path d="M838.75,72.6501 L838.75,85.1501 L851.25,85.1501 L838.75,72.6501 " fill="#FBFB77" style="stroke:#A80036;stroke-width:1.25;"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="237.5" x="13.75" y="97.5226">//协调动画、屏幕输入和绘制事件</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="403.75" x="13.75" y="119.7156">//过滤一帧内重复请求requestLayout(),测量，布局，绘制</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="497.5" x="13.75" y="141.9086">//从显示系统接收VSync垂直同步信号，从而安排下一帧绘制工作执行</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="137.5" x="13.75" y="164.1016">Choreographer.java</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="75" x="13.75" y="186.2946">//构造方法</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="398.75" x="13.75" y="208.4875">private Choreographer(Looper looper, int vsyncSource) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="131.25" x="33.75" y="230.6805">mLooper = looper;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="282.5" x="33.75" y="252.8735">mHandler = new FrameHandler(looper);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="357.5" x="33.75" y="275.0665">//向native层注册监听并接收Vsync信号回调的类，</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="550" x="33.75" y="297.2595">//一但有新的Vsync信号到达就会调用mDisplayEventReceiver.onVSync()方法</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="737.5" x="33.75" y="319.4525">mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource): null;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="341.6455"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="397.5" x="33.75" y="363.8385">//数组，每个元素都是队列，每个队列对应Callback类型</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="473.75" x="33.75" y="386.0315">mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="408.2245">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="430.4175"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="248.75" x="13.75" y="452.6105">private final class CallbackQueue {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="226.25" x="33.75" y="474.8035">private CallbackRecord mHead;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="496.9965"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="546.25" x="33.75" y="519.1895">public void addCallbackLocked(long dueTime, Object action, Object token) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="42.5" x="53.75" y="541.3824">//链表</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="537.5" x="53.75" y="563.5754">CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="157.5" x="53.75" y="585.7684">entry.next = callback;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="607.9614">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="630.1544">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="652.3474"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="123.75" x="13.75" y="674.5404">//接收VSync信号</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="413.75" x="13.75" y="696.7334">public void postFrameCallback(FrameCallback callback) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="292.5" x="33.75" y="718.9264">postFrameCallbackDelayed(callback, 0);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="741.1194">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="763.3124"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="172.5" x="13.75" y="785.5054">//可延迟接收VSync信号</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="593.75" x="13.75" y="807.6984">public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="147.5" x="33.75" y="829.8914">if (callback == null) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="470" x="53.75" y="852.0844">throw new IllegalArgumentException("callback must not be null");</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="874.2773">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="896.4703"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="777.5" x="33.75" y="918.6633">postCallbackDelayedInternal(CALLBACK_ANIMATION,callback, FRAME_CALLBACK_TOKEN, delayMillis);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="940.8563">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="963.0493"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="751.25" x="13.75" y="985.2423">private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="170" x="33.75" y="1007.4353">synchronized (mLock) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="416.25" x="53.75" y="1029.6283">//取队列，将参数封装成CallbackRecord对象放入队列尾部</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="563.75" x="53.75" y="1051.8213">mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="1074.0143"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="152.5" x="53.75" y="1096.2073">if (dueTime &lt;= now) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="238.75" x="73.75" y="1118.4003">//立刻执行scheduleFrameLocked</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="207.5" x="73.75" y="1140.5933">scheduleFrameLocked(now);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="50" x="53.75" y="1162.7863">} else {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="401.25" x="73.75" y="1184.9792">//发送消息，等轮询到的时候执行scheduleFrameLocked</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="635" x="73.75" y="1207.1722">Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="187.5" x="73.75" y="1229.3652">msg.arg1 = callbackType;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="205" x="73.75" y="1251.5582">msg.setAsynchronous(true);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="343.75" x="73.75" y="1273.7512">mHandler.sendMessageAtTime(msg, dueTime);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="53.75" y="1295.9442">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="1318.1372">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="1340.3302">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="1362.5232"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="1384.7162"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="331.25" x="13.75" y="1406.9092">private void scheduleFrameLocked(long now) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="172.5" x="33.75" y="1429.1022">if (!mFrameScheduled) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="296.25" x="53.75" y="1451.2952">mFrameScheduled = true;//防止多次触发</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="301.25" x="53.75" y="1473.4882">if (USE_VSYNC) {Android4.1之后默认true</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="1495.6812"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="597.5" x="73.75" y="1517.8741">//当前线程(调用postFromLocked()方法线程)与创建Choreographer线程是否是同一个</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="293.75" x="73.75" y="1540.0671">// return Looper.myLooper() == mLooper;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="285" x="73.75" y="1562.2601">if (isRunningOnLooperThreadLocked()) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="178.75" x="93.75" y="1584.4531">scheduleVsyncLocked();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="50" x="73.75" y="1606.6461">} else {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="552.5" x="93.75" y="1628.8391">Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="205" x="93.75" y="1651.0321">msg.setAsynchronous(true);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="338.75" x="93.75" y="1673.2251">mHandler.sendMessageAtFrontOfQueue(msg);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="73.75" y="1695.4181">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="50" x="53.75" y="1717.6111">} else {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="278.75" x="73.75" y="1739.8041">final long nextFrameTime = Math.max(</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="558.75" x="113.75" y="1761.9971">mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="167.5" x="73.75" y="1784.1901">if (DEBUG_FRAMES) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="545" x="93.75" y="1806.3831">Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms.");</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="73.75" y="1828.576">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="457.5" x="73.75" y="1850.769">Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="205" x="73.75" y="1872.962">msg.setAsynchronous(true);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="395" x="73.75" y="1895.155">mHandler.sendMessageAtTime(msg, nextFrameTime);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="53.75" y="1917.348">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="1939.541">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="1961.734">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="1983.927"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2006.12"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="267.5" x="13.75" y="2028.313">private void scheduleVsyncLocked() {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="237.5" x="33.75" y="2050.506">//向系统订阅一个新的VSync信号</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="300" x="33.75" y="2072.699">mDisplayEventReceiver.scheduleVsync();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="2094.892">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2117.085"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="187.5" x="13.75" y="2139.278">DisplayEventReceiver.java</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="211.25" x="13.75" y="2161.4709">public void scheduleVsync() {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="796.25" x="33.75" y="2183.6639">//向系统订阅一个新的VSync信号,一但新的Vsync信号到达就会调用FrameDisplayEventReceiver.onVsync()方法</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="266.25" x="33.75" y="2205.8569">nativeScheduleVsync(mReceiverPtr);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="2228.0499">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="10" x="13.75" y="2250.2429">//</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="723.75" x="13.75" y="2272.4359">private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="271.25" x="33.75" y="2294.6289">private boolean mHavePendingVsync;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="231.25" x="33.75" y="2316.8219">private long mTimestampNanos;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="138.75" x="33.75" y="2339.0149">private int mFrame;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2361.2079"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="491.25" x="33.75" y="2383.4009">public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="201.25" x="53.75" y="2405.5939">super(looper, vsyncSource);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="2427.7869">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2449.9799"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="75" x="33.75" y="2472.1729">@Override</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="565" x="33.75" y="2494.3658">public void onVsync(long timestampNanos, long physicalDisplayId, int frame) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="125" x="53.75" y="2516.5588">mFrame = frame;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="221.25" x="53.75" y="2538.7518">//创建一条消息，发送异步消息</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="336.25" x="53.75" y="2560.9448">//注意：此处创建msg传入Runnable callback，</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="586.25" x="53.75" y="2583.1378">//当消息被轮询到的时候就会回调执行run()方法，而不是交由handler msg处理消息</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="357.5" x="53.75" y="2605.3308">Message msg = Message.obtain(mHandler, this);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="205" x="53.75" y="2627.5238">msg.setAsynchronous(true);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="626.25" x="53.75" y="2649.7168">mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="2671.9098">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2694.1028"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="75" x="33.75" y="2716.2958">@Override</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="122.5" x="33.75" y="2738.4888">public void run() {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="212.5" x="53.75" y="2760.6818">mHavePendingVsync = false;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="10" x="53.75" y="2782.8748">//</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="288.75" x="53.75" y="2805.0677">doFrame(mTimestampNanos, mFrame);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="2827.2607">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="2849.4537">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="2871.6467"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="345" x="13.75" y="2893.8397">void doFrame(long frameTimeNanos, int frame) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="152.5" x="33.75" y="2916.0327">final long startNanos;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="170" x="33.75" y="2938.2257">synchronized (mLock) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="370" x="53.75" y="2960.4187">long intendedFrameTimeNanos = frameTimeNanos;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="245" x="53.75" y="2982.6117">startNanos = System.nanoTime();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="331.25" x="53.75" y="3004.8047">//计算差值=设备当前时间-Vsync信号到达时间</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="386.25" x="53.75" y="3026.9977">final long jitterNanos = startNanos - frameTimeNanos;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="506.25" x="53.75" y="3049.1907">//差值大于一帧时间mFrameIntervalNanos 16.7ms 说明这一帧绘制超时</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="296.25" x="53.75" y="3071.3837">if (jitterNanos &gt;= mFrameIntervalNanos) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="140" x="73.75" y="3093.5767">//计算出差了多少帧</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="453.75" x="73.75" y="3115.7697">final long skippedFrames = jitterNanos / mFrameIntervalNanos;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="141.25" x="73.75" y="3137.9626">//掉帧次数大于30帧</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="445" x="73.75" y="3160.1556">if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="75" x="93.75" y="3182.3486">//掉帧日志</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="390" x="93.75" y="3204.5416">Log.i(TAG, "Skipped " + skippedFrames + " frames!  "</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="500" x="133.75" y="3226.7346">+ "The application may be doing too much work on its main thread.");</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="73.75" y="3248.9276">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3271.1206"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="53.75" y="3293.3136">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3315.5066"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="3337.6996">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3359.8926"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="28.75" x="33.75" y="3382.0856">try {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="528.75" x="53.75" y="3404.2786">Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="611.25" x="53.75" y="3426.4716">AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3448.6646"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="273.75" x="53.75" y="3470.8575">mFrameInfo.markInputHandlingStart();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="177.5" x="53.75" y="3493.0505">//优先输入事件 用户交互</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="485" x="53.75" y="3515.2435">doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3537.4365"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="257.5" x="53.75" y="3559.6295">mFrameInfo.markAnimationsStart();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="307.5" x="53.75" y="3581.8225">//其次动画 动画越早执行页面看起来越柔顺</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="526.25" x="53.75" y="3604.0155">doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="592.5" x="53.75" y="3626.2085">doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3648.4015"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="305" x="53.75" y="3670.5945">mFrameInfo.markPerformTraversalsStart();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="535" x="53.75" y="3692.7875">doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3714.9805"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="502.5" x="53.75" y="3737.1735">doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="61.25" x="33.75" y="3759.3665">} finally {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="286.25" x="53.75" y="3781.5594">AnimationUtils.unlockAnimationClock();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="316.25" x="53.75" y="3803.7524">Trace.traceEnd(Trace.TRACE_TAG_VIEW);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="3825.9454">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3848.1384"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="3870.3314">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3892.5244"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="425" x="13.75" y="3914.7174">void doCallbacks(int callbackType, long frameTimeNanos) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="170" x="33.75" y="3936.9104">//取出Callback队列队头</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="798.75" x="33.75" y="3959.1034">callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="3981.2964"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="75" x="33.75" y="4003.4894">//循环队列</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="410" x="33.75" y="4025.6824">for (CallbackRecord c = callbacks; c != null; c = c.next) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="310" x="53.75" y="4047.8754">//回调到使用Choreographer注册监听的地方</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="172.5" x="53.75" y="4070.0684">c.run(frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="4092.2614">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="4114.4543">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="4136.6473"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="297.5" x="13.75" y="4158.8403">private static final class CallbackRecord {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="202.5" x="33.75" y="4181.0333">public CallbackRecord next;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="368.75" x="33.75" y="4203.2263">public Object action; // Runnable or FrameCallback</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="145" x="33.75" y="4225.4193">public Object token;</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="4247.6123"/><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="182.5" x="33.75" y="4269.8053">@UnsupportedAppUsage</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="278.75" x="33.75" y="4291.9983">public void run(long frameTimeNanos) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="317.5" x="53.75" y="4314.1913">if (token == FRAME_CALLBACK_TOKEN) {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="427.5" x="73.75" y="4336.3843">//回调使用Choreography注册监听的地方执行doFrame()重绘</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="377.5" x="73.75" y="4358.5773">((FrameCallback)action).doFrame(frameTimeNanos);</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="50" x="53.75" y="4380.7703">} else {</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="173.75" x="73.75" y="4402.9633">((Runnable)action).run();</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="53.75" y="4425.1563">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="33.75" y="4447.3492">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="5" x="13.75" y="4469.5422">}</text><text fill="#000000" font-family="sans-serif" font-size="16.25" lengthAdjust="spacing" textLength="0" x="18.75" y="4491.7352"/><!--MD5=[a71774f873e912e17c8c2a557f526c37]
@startuml
'https://plantuml.com/sequence-diagram

autonumber

'26 Activity之页面刷新机制  ViewRootImpl重绘
Choreographer.java - -> Choreographer.java:
activate Choreographer.java
note left
//协调动画、屏幕输入和绘制事件
//过滤一帧内重复请求requestLayout(),测量，布局，绘制
//从显示系统接收VSync垂直同步信号，从而安排下一帧绘制工作执行
Choreographer.java
//构造方法
private Choreographer(Looper looper, int vsyncSource) {
    mLooper = looper;
    mHandler = new FrameHandler(looper);
    //向native层注册监听并接收Vsync信号回调的类，
    //一但有新的Vsync信号到达就会调用mDisplayEventReceiver.onVSync()方法
    mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource): null;

    //数组，每个元素都是队列，每个队列对应Callback类型
    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];
}

private final class CallbackQueue {
    private CallbackRecord mHead;

    public void addCallbackLocked(long dueTime, Object action, Object token) {
        //链表
        CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);
        entry.next = callback;
    }
}

//接收VSync信号
public void postFrameCallback(FrameCallback callback) {
    postFrameCallbackDelayed(callback, 0);
}

//可延迟接收VSync信号
public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
    if (callback == null) {
        throw new IllegalArgumentException("callback must not be null");
    }

    postCallbackDelayedInternal(CALLBACK_ANIMATION,callback, FRAME_CALLBACK_TOKEN, delayMillis);
}

private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) {
    synchronized (mLock) {
        //取队列，将参数封装成CallbackRecord对象放入队列尾部
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

        if (dueTime <= now) {
            //立刻执行scheduleFrameLocked
            scheduleFrameLocked(now);
        } else {
            //发送消息，等轮询到的时候执行scheduleFrameLocked
            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
            msg.arg1 = callbackType;
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, dueTime);
        }
    }
}


private void scheduleFrameLocked(long now) {
    if (!mFrameScheduled) {
        mFrameScheduled = true;//防止多次触发
        if (USE_VSYNC) {Android4.1之后默认true

            //当前线程(调用postFromLocked()方法线程)与创建Choreographer线程是否是同一个
            // return Looper.myLooper() == mLooper;
            if (isRunningOnLooperThreadLocked()) {
                scheduleVsyncLocked();
            } else {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtFrontOfQueue(msg);
            }
        } else {
            final long nextFrameTime = Math.max(
                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
            if (DEBUG_FRAMES) {
                Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms.");
            }
            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, nextFrameTime);
        }
    }
}


private void scheduleVsyncLocked() {
    //向系统订阅一个新的VSync信号
    mDisplayEventReceiver.scheduleVsync();
}

DisplayEventReceiver.java
public void scheduleVsync() {
    //向系统订阅一个新的VSync信号,一但新的Vsync信号到达就会调用FrameDisplayEventReceiver.onVsync()方法
    nativeScheduleVsync(mReceiverPtr);
}
//
private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable {
    private boolean mHavePendingVsync;
    private long mTimestampNanos;
    private int mFrame;

    public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {
        super(looper, vsyncSource);
    }

    @Override
    public void onVsync(long timestampNanos, long physicalDisplayId, int frame) {
        mFrame = frame;
        //创建一条消息，发送异步消息
        //注意：此处创建msg传入Runnable callback，
        //当消息被轮询到的时候就会回调执行run()方法，而不是交由handler msg处理消息
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    }

    @Override
    public void run() {
        mHavePendingVsync = false;
        //
        doFrame(mTimestampNanos, mFrame);
    }
}

void doFrame(long frameTimeNanos, int frame) {
    final long startNanos;
    synchronized (mLock) {
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        //计算差值=设备当前时间-Vsync信号到达时间
        final long jitterNanos = startNanos - frameTimeNanos;
        //差值大于一帧时间mFrameIntervalNanos 16.7ms 说明这一帧绘制超时
        if (jitterNanos >= mFrameIntervalNanos) {
            //计算出差了多少帧
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            //掉帧次数大于30帧
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                //掉帧日志
                Log.i(TAG, "Skipped " + skippedFrames + " frames!  "
                        + "The application may be doing too much work on its main thread.");
            }

        }

    }

    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);

        mFrameInfo.markInputHandlingStart();
        //优先输入事件 用户交互
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);

        mFrameInfo.markAnimationsStart();
        //其次动画 动画越早执行页面看起来越柔顺
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);

        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);

        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }

}

void doCallbacks(int callbackType, long frameTimeNanos) {
    //取出Callback队列队头
    callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);

    //循环队列
    for (CallbackRecord c = callbacks; c != null; c = c.next) {
        //回调到使用Choreographer注册监听的地方
        c.run(frameTimeNanos);
    }
}

private static final class CallbackRecord {
    public CallbackRecord next;
    public Object action; // Runnable or FrameCallback
    public Object token;

    @UnsupportedAppUsage
    public void run(long frameTimeNanos) {
        if (token == FRAME_CALLBACK_TOKEN) {
            //回调使用Choreography注册监听的地方执行doFrame()重绘
            ((FrameCallback)action).doFrame(frameTimeNanos);
        } else {
            ((Runnable)action).run();
        }
    }
}

end note




@enduml

@startuml

autonumber

Choreographer.java - -> Choreographer.java:
activate Choreographer.java
note left
//协调动画、屏幕输入和绘制事件
//过滤一帧内重复请求requestLayout(),测量，布局，绘制
//从显示系统接收VSync垂直同步信号，从而安排下一帧绘制工作执行
Choreographer.java
//构造方法
private Choreographer(Looper looper, int vsyncSource) {
    mLooper = looper;
    mHandler = new FrameHandler(looper);
    //向native层注册监听并接收Vsync信号回调的类，
    //一但有新的Vsync信号到达就会调用mDisplayEventReceiver.onVSync()方法
    mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource): null;

    //数组，每个元素都是队列，每个队列对应Callback类型
    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];
}

private final class CallbackQueue {
    private CallbackRecord mHead;

    public void addCallbackLocked(long dueTime, Object action, Object token) {
        //链表
        CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);
        entry.next = callback;
    }
}

//接收VSync信号
public void postFrameCallback(FrameCallback callback) {
    postFrameCallbackDelayed(callback, 0);
}

//可延迟接收VSync信号
public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
    if (callback == null) {
        throw new IllegalArgumentException("callback must not be null");
    }

    postCallbackDelayedInternal(CALLBACK_ANIMATION,callback, FRAME_CALLBACK_TOKEN, delayMillis);
}

private void postCallbackDelayedInternal(int callbackType,Object action, Object token, long delayMillis) {
    synchronized (mLock) {
        //取队列，将参数封装成CallbackRecord对象放入队列尾部
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

        if (dueTime <= now) {
            //立刻执行scheduleFrameLocked
            scheduleFrameLocked(now);
        } else {
            //发送消息，等轮询到的时候执行scheduleFrameLocked
            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
            msg.arg1 = callbackType;
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, dueTime);
        }
    }
}


private void scheduleFrameLocked(long now) {
    if (!mFrameScheduled) {
        mFrameScheduled = true;//防止多次触发
        if (USE_VSYNC) {Android4.1之后默认true

            //当前线程(调用postFromLocked()方法线程)与创建Choreographer线程是否是同一个
            // return Looper.myLooper() == mLooper;
            if (isRunningOnLooperThreadLocked()) {
                scheduleVsyncLocked();
            } else {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtFrontOfQueue(msg);
            }
        } else {
            final long nextFrameTime = Math.max(
                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
            if (DEBUG_FRAMES) {
                Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms.");
            }
            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, nextFrameTime);
        }
    }
}


private void scheduleVsyncLocked() {
    //向系统订阅一个新的VSync信号
    mDisplayEventReceiver.scheduleVsync();
}

DisplayEventReceiver.java
public void scheduleVsync() {
    //向系统订阅一个新的VSync信号,一但新的Vsync信号到达就会调用FrameDisplayEventReceiver.onVsync()方法
    nativeScheduleVsync(mReceiverPtr);
}
//
private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable {
    private boolean mHavePendingVsync;
    private long mTimestampNanos;
    private int mFrame;

    public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {
        super(looper, vsyncSource);
    }

    @Override
    public void onVsync(long timestampNanos, long physicalDisplayId, int frame) {
        mFrame = frame;
        //创建一条消息，发送异步消息
        //注意：此处创建msg传入Runnable callback，
        //当消息被轮询到的时候就会回调执行run()方法，而不是交由handler msg处理消息
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    }

    @Override
    public void run() {
        mHavePendingVsync = false;
        //
        doFrame(mTimestampNanos, mFrame);
    }
}

void doFrame(long frameTimeNanos, int frame) {
    final long startNanos;
    synchronized (mLock) {
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        //计算差值=设备当前时间-Vsync信号到达时间
        final long jitterNanos = startNanos - frameTimeNanos;
        //差值大于一帧时间mFrameIntervalNanos 16.7ms 说明这一帧绘制超时
        if (jitterNanos >= mFrameIntervalNanos) {
            //计算出差了多少帧
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            //掉帧次数大于30帧
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                //掉帧日志
                Log.i(TAG, "Skipped " + skippedFrames + " frames!  "
                        + "The application may be doing too much work on its main thread.");
            }

        }

    }

    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);

        mFrameInfo.markInputHandlingStart();
        //优先输入事件 用户交互
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);

        mFrameInfo.markAnimationsStart();
        //其次动画 动画越早执行页面看起来越柔顺
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);

        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);

        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }

}

void doCallbacks(int callbackType, long frameTimeNanos) {
    //取出Callback队列队头
    callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);

    //循环队列
    for (CallbackRecord c = callbacks; c != null; c = c.next) {
        //回调到使用Choreographer注册监听的地方
        c.run(frameTimeNanos);
    }
}

private static final class CallbackRecord {
    public CallbackRecord next;
    public Object action; // Runnable or FrameCallback
    public Object token;

    @UnsupportedAppUsage
    public void run(long frameTimeNanos) {
        if (token == FRAME_CALLBACK_TOKEN) {
            //回调使用Choreography注册监听的地方执行doFrame()重绘
            ((FrameCallback)action).doFrame(frameTimeNanos);
        } else {
            ((Runnable)action).run();
        }
    }
}

end note




@enduml

PlantUML version 1.2021.00(Sun Jan 10 18:25:05 CST 2021)
(GPL source distribution)
Java Runtime: OpenJDK Runtime Environment
JVM: OpenJDK 64-Bit Server VM
Default Encoding: GBK
Language: zh
Country: CN
--></g></svg>